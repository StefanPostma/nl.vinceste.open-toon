'use strict';

const url = require('url');

const _ = require('underscore');
const uuid = require('uuid/v4');
const EventEmitter = require('events');

const OAuth2Account = require('./OAuth2Account');

class OAuth2Client extends EventEmitter {

	/**
	 * Construct an OAuth2Client instance, which handles OAuth2Account management.
	 * @param {Object} options
	 * @param {string} [options.id] - OAuth2 client identifier, or auto-generated uuid
	 * @param {string} options.url - OAuth2 authorization url
	 * @param {string} options.tokenEndpoint - OAuth2 token endpoint
	 * @param {string} options.key - OAuth2 client key
	 * @param {string} options.secret - OAuth2 client secret
	 * @param {string} [options.refreshingEnabled = true] - OAuth2 refresh grant enabled
	 * @param {string} options.allowMultipleAccounts - Specifies whether multiple accounts per client are allowed
	 */
	constructor(options = {}) {
		super();

		this._accounts = [];

		this.id = options.id || uuid();
		this.oauth2Url = options.url;
		this.tokenEndpoint = options.tokenEndpoint;
		this.key = options.key;
		this.secret = options.secret;
		this.refreshingEnabled = (options.hasOwnProperty('refreshingEnabled')) ? options.refreshingEnabled : true;
		this.allowMultipleAccounts = !!options.allowMultipleAccounts;
		this._log = options.log;

		// Hijack log method
		this.log = (...args) => {
			args.unshift('[OAuth2Client]');
			this._log.apply(null, args);
		};

		this.log(`new OAuth2Client constructed (id: ${this.id})`);
	}

	/**
	 * Returns important values that should be stored persistently.
	 * @returns {Object}
	 */
	getStoreValues() {
		return _.pick(this, 'oauth2Url', 'tokenEndpoint', 'key', 'secret', 'refreshingEnabled', 'allowMultipleAccounts');
	}

	/**
	 * Method that returns the accounts list of this client.
	 * @returns {Array}
	 */
	registeredAccounts() {
		return this._accounts;
	}

	/**
	 * Method that will return OAuth2Account if found by matching provided id.
	 * @param {string} id
	 * @returns {OAuth2Account|Error}
	 */
	getAccount(id) {
		if (id) {
			const foundAccount = this._accounts.find(account => account.id === id);
			if (foundAccount) return foundAccount;
			return new Error('could_not_find_account');
		} else if (!this.allowMultipleAccounts && this._accounts.length === 1) {
			return this._accounts[0];
		}
		return new Error('missing_account_id');
	}

	/**
	 * Factory method that will create a OAuth2Account.
	 * @param {Object} options
	 * @param {string} [options.id] - OAuth2 account identifier, or auto-generated uuid
	 * @param {OAuth2Client} [options.oauth2Client] - OAuth2Client associated with the to be created OAuth2Account
	 * @param {OAuth2Device} [options.oauth2Device] - OAuth2Device associated with the to be created OAuth2Account
	 * @param {string} [options.refreshingEnabled = true] - OAuth2 refresh grant enabled
	 * @param {string} [options.refreshToken] - OAuth2 refresh token
	 * @param {string} [options.accessToken] - OAuth2 access token
	 * @param {string|Date} [options.expiresIn] - Date object or string indicating when access token expires
	 * @returns {OAuth2Account|Error}
	 */
	createAccount(options = {}) {
		options.log = this._log;
		options.refreshingEnabled = this.refreshingEnabled;
		options.oauth2Client = this;
		this.log(`create OAuth2Account (id: ${options.id})`);
		return this._addAccount(new OAuth2Account(options));
	}

	/**
	 * Method that will add a OAuth2Account if allowed and if it is not already added, then it will return the
	 * instance that was already present.
	 * @param {OAuth2Account} account
	 * @returns {OAuth2Account|Error}
	 * @private
	 */
	_addAccount(account) {
		if (account && !(account instanceof OAuth2Account)) return new TypeError('account_is_not_instanceof_OAuth2Account');
		if (!this.allowMultipleAccounts && this._accounts.length > 0) {

			// If the ids differ, user is trying to add another unique account which is not allowed
			if (account.id !== this._accounts[0].id) return new Error('only_one_unique_account_allowed');

			this.log(`OAuth2Account was already added, return existing instance (id: ${account.id})`);

			// Ids are equal, consider this the same account
			return this._accounts[0];
		}
		if (this._accounts.length > 0) {

			// Check if account was already added
			const foundAccount = this.getAccount(account.id);

			// Account was already added, return known account and do not add new one
			if (foundAccount instanceof OAuth2Account) {
				this.log(`OAuth2Account was already added, return existing instance (id: ${foundAccount.id})`);
				return foundAccount;
			}

			// Account was not yet added check if more are allowed
			if (!this.allowMultipleAccounts) return new Error('only_one_account_allowed');
		}

		this.log(`new OAuth2Account was added (number of accounts: ${this._accounts.length + 1})`);

		this._accounts.push(account);
		return account;
	}

	/**
	 * Method that will delete a provided OAuth2Account. It calls the instance's destroy method and removes it from the
	 * accounts list.
	 * @param {OAuth2Account} account - OAuth2Account to be deleted
	 */
	deleteAccount(account) {
		account.destroy();
		this._accounts = this._accounts.filter(account_ => account_.id !== account.id);
		this.log(`OAuth2Account was destroyed (id: ${account.id}, number of accounts: ${this._accounts.length})`);
	}
}

module.exports = OAuth2Client;
